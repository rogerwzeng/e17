# -*- coding: utf-8 -*-
"""DGMD_PSET2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zvdND4JIWhrGGRad-8OigID84ihKMb3g

# Problem Set 2 (Undergraduate: 55 pts, Graduate: 70 pts)

In this problem set, you'll explore some concepts in linear algebra and the `numpy` library.
"""

### DO NOT CHANGE ###
# importing the libraries (do not remove or add libraries)
from typing import List, Set, Dict, Tuple, Optional
import numpy as np

"""## Linear Algebra (10 pts)

Linear algebra is a branch of mathematics that focuses on linear transformations and vector spaces. It is a fundamental area of mathematics with applications in various fields, including computer science, engineering, artificial intelligence, machine learning, computer vision, robotics, drones, autonomous vehicles, and more.

In this class, we'll leverage concepts, tools, and notation from linear algebra. In this section, you'll explore some core linear algebra operations: matrix multiplication and matrix-vector multiplication.

Given

\begin{align}
A = \begin{bmatrix}
1 & 5  \\
3 & 2  \\
6 & 8
\end{bmatrix},
B = \begin{bmatrix}
2 & 8 \\
6 & 4 \\
\end{bmatrix},
v = \begin{bmatrix}
2 \\
5 \\
\end{bmatrix}
\end{align}

Determine / calculate:
- `Av` (3 pts): $Av$
- `AB` (3 pts): $AB$
- `ABv` (4 pts): $ABv$

Your answer for each should be a list of lists. For reference, here's how we would express each of the above in Python as a list of lists:
```
A : List[List[float]] = [
    [1, 5],
    [3, 2],
    [6, 8]
]
B : List[List[float]] = [
    [2, 8],
    [6, 4]
]
v : List[List[float]] = [
    [2],
    [5]
]
```
For reference on how to do matrix / vector multiplication, please refer to these resources:
- [How to Multiply Matrices](https://www.mathsisfun.com/algebra/matrix-multiplying.html)
- [Matrix Multiplication Walkthrough Video](https://www.youtube.com/watch?v=zAjUyPe-4mI)
- [Multiplying Matrices and Vectors](https://mathinsight.org/matrix_vector_multiplication)

The spirit of this problem is to do it by hand to get familiar with matrix multiplication and matrix-vector multiplication (even though there are calculators / libraries to do it for us - you can use them to check your answers).
"""

Av : List[List[float]] = [[27],[16],[52]]

AB : List[List[float]] = [[32,28],[18,32],[60,80]]

ABv : List[List[float]] = [[204],[196],[520]]

print(f"Av = {Av}")
print(f"AB = {AB}")
print(f"ABv = {ABv}")

"""## NumPy Core (40 pts)

NumPy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays. It is also the bedrock for many other popular libraries that build on and use `numpy` underneath the hood. In this class, the `numpy` library will be integral.

This section will explore some of the core functionalities within the NumPy library.

### NumPy Functions (9 pts)

The NumPy library provides tools for various mathematical functions. Implement the following functions using the NumPy library (each 3 pts).


*   `function1` (3 pt): $4\sin(\pi x)+2$
*   `function2` (3 pt): $\log_2(x)+2\log_{10}(x^2)$
*   `function3` (3 pt): $4e^x + 9x^2$

**Hint**: documentation on [`np.sin`](https://numpy.org/doc/stable/reference/generated/numpy.sin.html), [`np.log2`](https://numpy.org/doc/stable/reference/generated/numpy.log2.html), [`np.log10`](https://numpy.org/doc/stable/reference/generated/numpy.log10.html), [`np.exp`](https://numpy.org/doc/stable/reference/generated/numpy.exp.html), and [python math operations](https://www.programiz.com/python-programming/operators) will be helpful.
"""

def function1(x: float) -> np.float64:
    return 4*np.sin(np.pi*x)+2

def function2(x: float) -> np.float64:
    return np.log2(x) + 2* np.log10(x*x)

def function3(x: float) -> np.float64:
    return 4*np.exp(x) + 9*x*x

"""### Dot Product (5 pts)

`dot_product` (5 pts): Given two numeric numpy arrays, `v1` and `v2`, return the dot product. If the two arrays are the wrong dimension or size, return `None` instead. **Hint**: Documentation on [`np.ndarray.ndim`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html), [`np.ndarray.shape`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html), and [`np.dot`](https://numpy.org/doc/stable/reference/generated/numpy.dot.html) will be helpful. **Notice**: this question is very similar to `array_prod` from a previous pset.
"""

def dot_product(v1: np.ndarray, v2: np.ndarray) -> Optional[np.float64]:
    if v1.shape[-1] != v2.shape[0]:
        return None
    try:
        return np.dot(v1, v2)
    except ValueError:
        return None

"""### Calculate Sigma Metric (5 pts)

`calculate_sigma_metric` (5 pts): Assume the values for `x` and `y` will be 1-dimensional numeric numpy arrays of the same length and dimension. Complete the function `calculate_metric` that calculates this metric defined below:

\begin{align}
x &= [x_1, x_2, ..., x_n]\\
y &= [y_1, y_2, ..., y_n]\\
M &= \sum_{i=0}^n (x_i - y_i)^2
\end{align}

**Hint**: Documention on [numpy operations](https://www.pluralsight.com/guides/overview-basic-numpy-operations), [`np.power`](https://numpy.org/doc/stable/reference/generated/numpy.power.html), and [`np.sum`](https://numpy.org/doc/stable/reference/generated/numpy.sum.html) will be helpful. Additionally, here's a [resource](https://www.mathsisfun.com/algebra/sigma-notation.html) on the $\sum$ (sigma) operator.

**Note**: The above metric is often used to represent the total sum of squared error (SSE) in many statistical and machine learning models.
"""

def calculate_sigma_metric(x: np.ndarray, y: np.ndarray) -> np.float64:
    if len(x) != len(y):
        print("Arrays are of different lengths.")
    else:
        return np.sum((x - y) ** 2)

"""### Matrix Splice (15 pts)

NumPy offers a very powerful and expressive indexing scheme, letting use slice and dice matrices faster and more efficiently. The next problem will get you familiar with it's indexing capabilities.

`matrix_splice` (15 pts): Given a 2D numeric numpy matrix `A`, a row index `r`, and a column index `c`, return the sum of the row vector of `A` at index `r` and the column vector of `A` at index `c` (following python indexing rules, i.e., starts at zero and supports positive and negative indexing). Edge cases to handle are invalid index values for the matrix `A` and summing vectors of different size (this happens when the width and height of the matrix are different) - the return value for these cases should be `None`.

**Example 1**:

```python
A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
])
r = 1
c = 1

matrix_splice(A, r, c) = [6, 10, 14]
```
Explanation: Get the row at index 1, which is `[4, 5, 6]`, get the column at index 1, which is `[2, 5, 8]`, and sum the vectors (i.e., along each component), so `[4 + 2, 5 + 5, 6 + 8]`, which is `[6, 10, 14]`

**Example 2**:

```python
A = np.array([
    [1, 2, 3],
    [4, 5, 6],
])
r = 1
c = 1

matrix_splice(A, r, c) = None
```
Explanation: Get the row at index 1, which is `[4, 5, 6]` and get the column at index 1, which is `[2, 5]`. The dimensions of the resulting vectors are different so we can't add them together. Thus, we return `None`.

**Example 3**:

```python
A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
])
r = 3
c = 1

matrix_splice(A, r, c) = None
```
Explanation: There's no row at index 3, as the positive index range for matrix `A` is 0 to 2. Thus, we have an invalid value for `r` and will return `None`.

**Example 4**:

```python
A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
])
r = -4
c = 1

matrix_splice(A, r, c) = None
```
Explanation: There's no row at index -4, as the negative index range for matrix `A` is -1 to -3. Thus, we have an invalid value for `r` and will return `None`.

**Hint**: Documentation on [numpy operations](https://www.pluralsight.com/guides/overview-basic-numpy-operations), [numpy array splicing](https://machinelearningmastery.com/index-slice-reshape-numpy-arrays-machine-learning-python/), [`np.transpose`](https://numpy.org/doc/stable/reference/generated/numpy.transpose.html), [`np.ndarray.ndim`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html), and [`np.ndarray.shape`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html) will be helpful. The syntax for indexing with numpy is different from normal Python.
"""

def matrix_splice(A: np.ndarray, r: int, c: int) -> Optional[np.ndarray]:
    if (0 <= r < A.shape[0]) and (0 <= c < A.shape[1]):
        row_vector = A[r, :]
        col_vector = A[:, c]

        # If the row vector and the column vector are of the same length
        if row_vector.shape[0] == col_vector.shape[0]:
            return row_vector + col_vector
        else:
            return None
    else:
        # Return None if the indices are out of range
        return None

"""### Matrix Rotation (6 pts)

`matrix_rotation` (6 pts): Given a matrix `A`, rotate it by $-90^{\circ}$ (i.e., 90 degrees counter-clockwise). **Hint**: this can be done with indexing and / or the transpose function.

**Example 1**:

```python
A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
])

matrix_rotation(A) = np.array([
    [3, 6, 9],
    [2, 5, 8],
    [1, 4, 7],
])
```

**Example 2**:

```python
A = np.array([
    [1, 2, 3, 4],
    [5, 6, 7, 8]
])

matrix_rotation(A) = np.array([
    [4, 8],
    [3, 7],
    [2, 6],
    [1, 5]
])
```

**Note**: we often represent images as a matrix of numbers where each number represents a light / color intensity (see [example](https://i.stack.imgur.com/z4SLa.jpg)).

<center><img src="https://i.stack.imgur.com/z4SLa.jpg"></center>

When we want to rotate or flip an image, that is equivalent to rotating or flipping the matrix. If you utilize the above function for an image, it produces a new image rotated 90 degrees counter-clockwise.
"""

def matrix_rotation(A: np.ndarray) -> np.ndarray:
    return np.flip(A.T, axis=0)

"""## Graduate Problems (15 pts)

This section is intended for graduate students. Undergraduate students may complete this section for extra credit points.

**Graduate students should check the box below to receive credit for the graduate problems**. Undergraduate who are attempting the graduate problems for extra credit should also check the box. If you're an undergraduate not doing the graduate problems, leave the box unchecked.
"""

#@title Graduate Problem Toggle

#@markdown Will you be completing the graduate problems?
graduate_problem_toggle = True # @param {type:"boolean"}

"""### System Cardinality (5 pts)

When faced with a new (engineering) problem, we often create a mathematical model that represents the situation or process. This mathematical model can then be analyzed, manipulated, and used to gain insights, make predictions, or solve the problem. A common pattern or structure for this mathematical model is to create a system of equations that capture the dynamics of the situation.

In particular, we often construct the model as a linear system of equations. The reasons why for we use a linear system of equations are:
- it easy to construct and understand
- we have software and algorithms to solve linear systems efficiently (e.g., `numpy`, MATLAB, linear algebra)
- it can work well enough, even in non-linear situations (e.g., Talyor series expansion)

For this problem, we'll focus specifically on linear systems of equations with 2 equations and 2 variables:

\begin{align}
a_1 x_1 + b_1 x_2 &= c_1 \\
a_2 x_1 + b_2 x_2 &= c_2
\end{align}

where $x_1$ and $x_2$ are the 2 variables, and $a_1, b_1, c_1, a_2, b_2$, and $c_2$ are constants or coefficients.

When solving a linear systems of equations with 2 equations and 2 variables, there are three possible scenarios for the solution set for values $x_1$ and $x_2$:
- The solution set contains zero elements
- The solution set contains exactly one element
- The solution set contains an infinite number of elements

`system_cardinality` (5 pts): Given $a_1, b_1, c_1, a_2, b_2$, and $c_2$, return `0` if the solution set contains zero elements, `1` if the solution set contains exactly one element, or `np.inf` if the solution set contains an infinite number of elements.

**Example 1**
```python
a1, b1, c1, a2, b2, c2 = 2.5, 3.5, 2, 1.25, 1.75, 1.5
system_cardinality(a1, b1, c1, a2, b2, c2) = 0
```
Explanation: There is no value of $x_1$ and $x_2$ that satisfies both  equations simultaneously

**Example 2**
```python
a1, b1, c1, a2, b2, c2 = 3, 4, 2, 5, 7, 6
system_cardinality(a1, b1, c1, a2, b2, c2) = 1
```
Explanation: There is only 1 value of $x_1$ and $x_2$ that satisfies both  equations simultaneously: $x_1 = -10$ and $x_2 = 8$

**Example 3**
```python
a1, b1, c1, a2, b2, c2 = 1, 7, 8, 0.5, 3.5, 4
system_cardinality(a1, b1, c1, a2, b2, c2) = np.inf
```
Explanation: Any value of $x_1$ and $x_2$ that satisfies one of the equations will also satisfy the other equation

**Hint**: Documentation on [`np.linalg.solve`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html) will be helpful.
"""

def system_cardinality(a1: float, b1: float, c1: float,
                       a2: float, b2: float, c2: float) -> float:
    # Coefficients matrix and constant matrix
    A = np.array([[a1, b1], [a2, b2]])
    C = np.array([c1, c2])

    try:
        X = np.linalg.solve(A, C)
        return 1
    except np.linalg.LinAlgError:
        return 0 if np.linalg.matrix_rank(A) < np.linalg.matrix_rank(np.column_stack((A, C))) else np.inf

"""### Sensor Stream (10 pts)

Sensors take measurements of our environment. For example, a temperature sensor captures the temperature of the environment. We often collect multiple measurements from a sensor over a period of time (how frequently a sensor can capture measurement is called the sensor's sampling rate or frequency). For sensors that capture a single value measurement, like temperature, over some period of time, we can represent that data as a list of numbers ordered by the time the measurement was captured. In the below example, we have 5 measurements from a temperature sensor stored as a list.

```python
data = [60, 59, 57, 62, 61]
```

When we collect data from sensors, a common operation we want to perform is to calculate some summary statistics, such as the mean and standard deviation of the sensor data. If we have the entirety of the sensor data, we can load it all into memory and then calculate the relevant summary statistics, like in the example below.

```python
# all the measurements are loaded in memory
data = [60, 59, 57, 62, 61]

# calculating the mean
np.mean(data) # 59.8

# calculating the standard deviation
np.std(data) # ~1.72
```

The above approach works great! But we can only calculate these summary statistics after all the data has been collected. While the sensor data is being actively collected, we can't actually do the above as we don't have the complete set of data. There are scenarios where we would be collecting sensor data for a very long time or indefinitely (i.e., the sensor always needs to be on and collecting, such as in an autonomous vehicle). In these scenarios, we would represent the data as a stream of number, where we would calculate the summary statistics as new measurements were collected.

`SensorStream` (10 pts): Implement the `SensorStream` class which will calculate the mean and standard deviation of the sensor data as new measurements are received. The constraints for your implementation are:
- The SensorStream class should have no instance variables (i.e., should be instantiate with just `SensorStream()`)
- It should have the three methods that come with the base template implemented with the following functionality:
    - `mean`: returns the mean value of the data provided so far; has no input parameter
    - `standard_deviation`: returns the standard deviation of the data provided so far; has no input parameter
    - `new_measurement`: intake a new measurements; has one input paramater, `m`, which is the new measurement
- It should be memory efficient and be less than $O(n)$ memory where $n$ is the number of sensor data points seen up to that point (**Note**: for those curious, you can implement this with $O(1)$ memory usage)
- You can add as many attributes or additional methods needed into the class for the implementation

**Example**
```python
# make a SensorStream object
stream = SensorStream()

# add a new measurement and calculate mean and standard deviation
stream.new_measurement(60)
stream.mean()               # 60
stream.standard_deviation() # 0

# add a new measurement and calculate mean and standard deviation
stream.new_measurement(59)
stream.mean()               # 59.5
stream.standard_deviation() # 0.5

# add a new measurement and calculate mean and standard deviation
stream.new_measurement(57)
stream.mean()               # ~58.66
stream.standard_deviation() # ~1.25

# add a new measurement and calculate mean and standard deviation
stream.new_measurement(62)
stream.mean()               # 59.5
stream.standard_deviation() # ~1.80

# add a new measurement and calculate mean and standard deviation
stream.new_measurement(61)
stream.mean()               # 59.8
stream.standard_deviation() # ~1.72
```
Explanation: each time a new measurement is added, we have a new mean and standard deviation. The above is the expected class behavior.
"""

class SensorStream:
    def __init__(self) -> None:
        self.avg = 0
        self.sd = 0
        self.n = 0
        self.sumxsq = 0

    def mean(self) -> float:
        return self.avg

    def standard_deviation(self) -> float:
        return self.sd

    def new_measurement(self, data: float) -> None:
        if self.n == 0:
            self.avg = data
            self.n = 1
            self.sumxsq = data**2
            self.sd = 0
        else:
            # update standard deviation, mean and measurement count
            self.avg = (self.avg * self.n + data)/(self.n + 1)
            self.n = self.n + 1
            self.sumxsq = self.sumxsq + data**2
            self.sd = np.sqrt((self.sumxsq - self.n*(self.avg**2))/self.n)

"""## Problem Set Survey (5 pts)

Please fill out the survey questions (the first five are each worth 1 point; the last one is optional).


1.   `TIME` (1 pt): approximately how many hours did you spend on the problem set? Please use decimals to express partial hours (e.g., a value of `2.5` means two and half hours).
2.   `DIFFICULTY` (1 pt): on a scale of 1-10, how difficult was this problem set with 1 being very easy and 10 being very hard?
3.   `FAVORITE_PART` (1 pt): What was your favorite topic / learning from the unit (i.e., between the last pset and this pset)? This should contain at least 10 words.
4.   `WENT_WELL` (1 pt): What went well? Describe what went well with the course so far (this can be about the lecture, assignments, and/or other course content). This should contain at least 10 words.
5.   `CHALLENGING` (1 pt): What was challenging? Describe what was challenging or didn't go well with the course so far (this can be about the lecture, assignments, and/or other course content). This should contain at least 10 words.
6.   `COMMENTARY` (0 pt): If there is anything else you'd like to share with course staff, please add it here. If not, no need to change / edit the default string.
"""

#@title Problem Set Survey Questions
TIME = "4.5" #@param {type:"string"}

DIFFICULTY = "4" #@param ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

FAVORITE_PART = "It was tricky to update the variance in the last question with a new observation." #@param {type:"string"}

WENT_WELL = "a refresher on NumPy with matrix operations and a good introduction to handling streaming data" #@param {type:"string"}

CHALLENGING = "Updating variance of streaming data with O(1) complexity didn't work until I did some more research on MathStackExchange" #@param {type:"string"}

COMMENTARY = "" #@param {type:"string"}

"""**<font color='red'>To submit, please download as a Python (.py) file and submit on Gradescope (navigate to File > Download > Download .py). Please use the correct file name and comment out any test / extraneous code to avoid any compile and parser issues </font>**"""